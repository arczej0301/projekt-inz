import React, { useState, useMemo } from 'react'
import { useFinance } from '../../hooks/useFinance'
import CustomSelect from '../CustomSelect'
import './FinanceComponents.css'

const ExpensesTab = ({ transactions }) => {
  const { expenseCategories, addTransaction } = useFinance()
  const [showAddForm, setShowAddForm] = useState(false)
  
  // Stan dla sortowania
  const [sortOption, setSortOption] = useState('date_desc')
  const [filterOption, setFilterOption] = useState('all')
  
  const [newTransaction, setNewTransaction] = useState({
    type: 'expense',
    category: '',
    amount: '',
    description: '',
    date: new Date().toISOString().split('T')[0]
  })

  // Poprawiona funkcja do formatowania waluty
  const formatCurrency = (amount) => {
    if (amount === null || amount === undefined || isNaN(amount)) {
      return '0,00 z≈Ç'
    }
    
    const numAmount = parseFloat(amount)
    const formatted = numAmount.toFixed(2).replace('.', ',').replace(/\B(?=(\d{3})+(?!\d))/g, ' ')
    return `${formatted} z≈Ç`
  }

  // Opcje sortowania i filtrowania
  const sortOptions = [
    { value: 'date_desc', label: 'Najnowsze' },
    { value: 'date_asc', label: 'Najstarsze' },
    { value: 'amount_desc', label: 'Najwiƒôksze kwoty' },
    { value: 'amount_asc', label: 'Najmniejsze kwoty' },
    { value: 'category', label: 'Kategoria A-Z' }
  ]

  const filterOptions = [
    { value: 'all', label: 'Wszystkie' },
    { value: 'auto', label: 'Auto-generowane' },
    { value: 'manual', label: 'Rƒôczne' }
  ]

  // Przygotuj opcje dla CustomSelect
  const categoryOptions = expenseCategories.map(cat => ({
    value: cat.id,
    label: cat.name,
    icon: cat.icon
  }))

  // Sortowanie i filtrowanie transakcji
  const sortedTransactions = useMemo(() => {
    let filtered = [...transactions]
    
    // Filtrowanie
    if (filterOption === 'auto') {
      filtered = filtered.filter(t => t.autoGenerated)
    } else if (filterOption === 'manual') {
      filtered = filtered.filter(t => !t.autoGenerated)
    }
    
    // Sortowanie
    return filtered.sort((a, b) => {
      const getDate = (t) => {
        if (t.date?.toDate) return t.date.toDate()
        if (t.date instanceof Date) return t.date
        if (t.createdAt?.toDate) return t.createdAt.toDate()
        return new Date(t.date || t.createdAt || 0)
      }
      
      switch(sortOption) {
        case 'date_asc':
          return getDate(a).getTime() - getDate(b).getTime()
          
        case 'date_desc':
          return getDate(b).getTime() - getDate(a).getTime()
          
        case 'amount_desc':
          return b.amount - a.amount
          
        case 'amount_asc':
          return a.amount - b.amount
          
        case 'category':
          const catA = expenseCategories.find(c => c.id === a.category)?.name || a.category
          const catB = expenseCategories.find(c => c.id === b.category)?.name || b.category
          return catA.localeCompare(catB)
          
        default:
          return getDate(b).getTime() - getDate(a).getTime()
      }
    })
  }, [transactions, sortOption, filterOption, expenseCategories])

  const handleAddTransaction = async (e) => {
    e.preventDefault()
    if (!newTransaction.category || !newTransaction.amount || !newTransaction.description) {
      alert('Proszƒô wype≈Çniƒá wszystkie pola')
      return
    }

    const result = await addTransaction(newTransaction)
    if (result.success) {
      setShowAddForm(false)
      setNewTransaction({
        type: 'expense',
        category: '',
        amount: '',
        description: '',
        date: new Date().toISOString().split('T')[0]
      })
    } else {
      alert('B≈ÇƒÖd przy dodawaniu transakcji: ' + result.error)
    }
  }

  const totalExpenses = sortedTransactions.reduce((sum, t) => sum + t.amount, 0)

  return (
    <div className="expenses-tab">
      <div className="tab-header">
        <h3>Koszty</h3>
        <div className="tab-actions">
          {/* SEKCJA SORTOWANIA I FILTROWANIA */}
          <div className="sort-filter-section">
            <label>Sortowanie</label>
            <select 
              className="control-select"
              value={filterOption}
              onChange={(e) => setFilterOption(e.target.value)}
            >
              {filterOptions.map(option => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
            
            <select 
              className="control-select"
              value={sortOption}
              onChange={(e) => setSortOption(e.target.value)}
            >
              {sortOptions.map(option => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </div>
          
          <button 
            className="btn btn-primary"
            onClick={() => setShowAddForm(true)}
          >
            + Dodaj koszt
          </button>
        </div>
      </div>

      <div className="total-summary">
        ≈ÅƒÖczne koszty: <strong>{formatCurrency(totalExpenses)}</strong>
        {filterOption !== 'all' && (
          <span className="filter-info">
            (Filtr: {filterOptions.find(f => f.value === filterOption)?.label})
          </span>
        )}
      </div>

      {/* Reszta kodu pozostaje bez zmian */}
      {showAddForm && (
        <div className="modal-overlay">
          <div className="modal-content">
            <div className="modal-header">
              <h4>Dodaj nowy koszt</h4>
              <button className="close-btn" onClick={() => setShowAddForm(false)}>√ó</button>
            </div>
            <form onSubmit={handleAddTransaction}>
              <div className="form-group">
                <label>Kategoria *</label>
                <CustomSelect
                  options={categoryOptions}
                  value={newTransaction.category}
                  onChange={(value) => setNewTransaction(prev => ({...prev, category: value}))}
                  placeholder="Wybierz kategoriƒô..."
                  searchable={true}
                />
              </div>

              <div className="form-group">
                <label>Kwota (z≈Ç) *</label>
                <input 
                  type="number" 
                  step="0.01"
                  value={newTransaction.amount}
                  onChange={(e) => setNewTransaction(prev => ({...prev, amount: e.target.value}))}
                  required
                />
              </div>

              <div className="form-group">
                <label>Opis *</label>
                <input 
                  type="text" 
                  value={newTransaction.description}
                  onChange={(e) => setNewTransaction(prev => ({...prev, description: e.target.value}))}
                  required
                />
              </div>

              <div className="form-group">
                <label>Data</label>
                <input 
                  type="date" 
                  value={newTransaction.date}
                  onChange={(e) => setNewTransaction(prev => ({...prev, date: e.target.value}))}
                />
              </div>

              <div className="form-actions">
                <button type="button" className="btn btn-secondary" onClick={() => setShowAddForm(false)}>
                  Anuluj
                </button>
                <button type="submit" className="btn btn-primary">
                  Dodaj koszt
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      <div className="transactions-table">
        <table>
          <thead>
            <tr>
              <th>Data</th>
              <th>Kategoria</th>
              <th>Opis</th>
              <th>Kwota</th>
              <th>≈πr√≥d≈Ço</th>
            </tr>
          </thead>
          <tbody>
            {sortedTransactions.map(transaction => (
              <tr key={transaction.id}>
                <td>{transaction.date?.toLocaleDateString?.() || new Date(transaction.date).toLocaleDateString()}</td>
                <td>
                  <span className="category-with-icon">
                    <span className="icon">
                      {expenseCategories.find(cat => cat.id === transaction.category)?.icon || 'üìâ'}
                    </span>
                    {expenseCategories.find(cat => cat.id === transaction.category)?.name || transaction.category}
                  </span>
                </td>
                <td>{transaction.description}</td>
                <td className="amount negative">-{formatCurrency(transaction.amount)}</td>
                <td>
                  {transaction.autoGenerated ? (
                    <span className="auto-badge">Auto</span>
                  ) : (
                    <span className="manual-badge">Rƒôczne</span>
                  )}
                </td>
              </tr>
            ))}
            {sortedTransactions.length === 0 && (
              <tr>
                <td colSpan="5" className="no-data">Brak transakcji kosztowych</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  )
}

export default ExpensesTab