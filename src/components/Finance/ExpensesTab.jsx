import React, { useState, useMemo, useEffect } from 'react'
import { useFinance } from '../../hooks/useFinance'
import CustomSelect from '../common/CustomSelect'
import { db } from '../../config/firebase'
import { collection, query, where, getDocs, orderBy, limit } from 'firebase/firestore'
import './FinanceComponents.css'

const ExpensesTab = ({ transactions }) => {
  const { expenseCategories, addTransaction } = useFinance()
  const [sortOption, setSortOption] = useState('date_desc')
  const [filterOption, setFilterOption] = useState('all')
  const [showAddForm, setShowAddForm] = useState(() => {
    return localStorage.getItem('openExpenseForm') === 'true';
  })

   // DODAJ TEN useEffect:
  useEffect(() => {
    // Je≈õli jest flaga w localStorage, otw√≥rz formularz
    const shouldOpenForm = localStorage.getItem('openExpenseForm');
    if (shouldOpenForm === 'true') {
      setShowAddForm(true);
      // Wyczy≈õƒá flagƒô po otwarciu
      localStorage.removeItem('openExpenseForm');
    }
  }, []);

  const [newTransaction, setNewTransaction] = useState({
    type: 'expense',
    category: '',
    amount: '',
    description: '',
    date: new Date().toISOString().split('T')[0]
  })

  useEffect(() => {
  // Je≈õli jest flaga w localStorage, otw√≥rz formularz
  const shouldOpenForm = localStorage.getItem('openExpenseForm');
  if (shouldOpenForm === 'true') {
    setShowAddForm(true);
    // Wyczy≈õƒá flagƒô po otwarciu
    localStorage.removeItem('openExpenseForm');
  }
}, []);

const [partsData, setPartsData] = useState({})

  // Pobierz tylko czƒô≈õci z Firestore
  useEffect(() => {
    const fetchPartsData = async () => {
      // Znajd≈∫ transakcje z gara≈ºu
      const garageTransactions = transactions.filter(
        t => t.autoGenerated && t.source === 'garage' && t.sourceId
      )

      if (garageTransactions.length === 0) {
        setPartsData({})
        return
      }

      const partsMap = {}

      // Dla ka≈ºdej transakcji znajd≈∫ czƒô≈õci
      for (const transaction of garageTransactions) {
        try {
          console.log('üîç Szukam czƒô≈õci dla transakcji:', {
            id: transaction.id,
            sourceId: transaction.sourceId,
            description: transaction.description,
            date: transaction.date
          })

          const repairsRef = collection(db, 'repairs')
          // Szukaj napraw dla tej maszyny (machineId = sourceId z transakcji)
          const q = query(
            repairsRef,
            where('machineId', '==', transaction.sourceId)
          )

          const querySnapshot = await getDocs(q)
          console.log(`üìä Znaleziono ${querySnapshot.size} napraw dla machineId: ${transaction.sourceId}`)

          if (!querySnapshot.empty) {
            // Przejd≈∫ przez wszystkie naprawy
            querySnapshot.forEach((doc, index) => {
              const repairData = doc.data()
              console.log(`üîß Naprawa ${index + 1}:`, {
                id: doc.id,
                machineId: repairData.machineId,
                parts: repairData.parts,
                date: repairData.date,
                description: repairData.description
              })
            })

            // We≈∫ najnowszƒÖ naprawƒô (posortuj po dacie)
            const repairs = []
            querySnapshot.forEach((doc) => {
              const repairData = doc.data()
              repairs.push({
                ...repairData,
                id: doc.id,
                date: repairData.date || repairData.createdAt?.toDate?.() || new Date()
              })
            })

            // Sortuj od najnowszej
            repairs.sort((a, b) => new Date(b.date) - new Date(a.date))

            const latestRepair = repairs[0]
            console.log('‚úÖ Najnowsza naprawa:', latestRepair)

            // Zapisz czƒô≈õci je≈õli istniejƒÖ
            if (latestRepair.parts && latestRepair.parts.trim() !== '') {
              partsMap[transaction.id] = latestRepair.parts.trim()
              console.log(`üíæ Zapisano czƒô≈õci dla transakcji ${transaction.id}:`, latestRepair.parts)
            } else {
              console.log(`‚ö†Ô∏è Brak czƒô≈õci w najnowszej naprawie dla transakcji ${transaction.id}`)
              partsMap[transaction.id] = null
            }
          } else {
            console.log(`‚ùå Nie znaleziono ≈ºadnych napraw dla machineId: ${transaction.sourceId}`)
            partsMap[transaction.id] = null
          }
        } catch (error) {
          console.error('‚ùå B≈ÇƒÖd pobierania czƒô≈õci dla transakcji:', transaction.id, error)
          partsMap[transaction.id] = null
        }
      }

      console.log('üìã Ostateczna mapa czƒô≈õci:', partsMap)
      setPartsData(partsMap)
    }

    fetchPartsData()
  }, [transactions])

  // Funkcja formatowania waluty (bez zmian)
  const formatCurrency = (amount) => {
    if (amount === null || amount === undefined || isNaN(amount)) {
      return '0,00 z≈Ç'
    }

    const numAmount = parseFloat(amount)
    const formatted = numAmount.toFixed(2).replace('.', ',').replace(/\B(?=(\d{3})+(?!\d))/g, ' ')
    return `${formatted} z≈Ç`
  }

  // Opcje sortowania i filtrowania (bez zmian)
  const sortOptions = [
    { value: 'date_desc', label: 'Najnowsze' },
    { value: 'date_asc', label: 'Najstarsze' },
    { value: 'amount_desc', label: 'Najwiƒôksze kwoty' },
    { value: 'amount_asc', label: 'Najmniejsze kwoty' },
    { value: 'category', label: 'Kategoria A-Z' }
  ]

  const filterOptions = [
    { value: 'all', label: 'Wszystkie kategorie' },
    { value: 'zwierzeta', label: 'Zwierzƒôta' },
    { value: 'maszyny', label: 'Maszyny' },
    { value: 'zboza', label: 'Zbo≈ºa' },
    { value: 'nawozy_nasiona', label: 'Nawozy i nasiona' },
    { value: 'pasze', label: 'Pasze' },
    { value: 'paliwo', label: 'Paliwo' },
    { value: 'sprzet_czesci', label: 'Sprzƒôt i czƒô≈õci' },
    { value: 'naprawa_konserwacja', label: 'Naprawa i konserwacja' },
    { value: 'auto', label: 'Auto-generowane' },
    { value: 'manual', label: 'Rƒôczne' }
  ]

  // Przygotuj opcje dla CustomSelect
  const categoryOptions = expenseCategories.map(cat => ({
    value: cat.id,
    label: cat.name,
    icon: cat.icon
  }))

  // Sortowanie i filtrowanie transakcji (bez zmian)
  const sortedTransactions = useMemo(() => {
    let filtered = [...transactions]

    // Filtrowanie
    if (filterOption !== 'all') {
      if (filterOption === 'auto') {
        filtered = filtered.filter(t => t.autoGenerated)
      } else if (filterOption === 'manual') {
        filtered = filtered.filter(t => !t.autoGenerated)
      } else {
        filtered = filtered.filter(t => t.category === filterOption)
      }
    }

    // Sortowanie
    return filtered.sort((a, b) => {
      const getDate = (t) => {
        if (t.date?.toDate) return t.date.toDate()
        if (t.date instanceof Date) return t.date
        if (t.createdAt?.toDate) return t.createdAt.toDate()
        return new Date(t.date || t.createdAt || 0)
      }

      switch (sortOption) {
        case 'date_asc':
          return getDate(a).getTime() - getDate(b).getTime()

        case 'date_desc':
          return getDate(b).getTime() - getDate(a).getTime()

        case 'amount_desc':
          return b.amount - a.amount

        case 'amount_asc':
          return a.amount - b.amount

        case 'category':
          const catA = expenseCategories.find(c => c.id === a.category)?.name || a.category
          const catB = expenseCategories.find(c => c.id === b.category)?.name || b.category
          return catA.localeCompare(catB)

        default:
          return getDate(b).getTime() - getDate(a).getTime()
      }
    })
  }, [transactions, sortOption, filterOption, expenseCategories])

  const handleAddTransaction = async (e) => {
    e.preventDefault()
    if (!newTransaction.category || !newTransaction.amount || !newTransaction.description) {
      alert('Proszƒô wype≈Çniƒá wszystkie pola')
      return
    }

    const result = await addTransaction(newTransaction)
    if (result.success) {
      setShowAddForm(false)
      setNewTransaction({
        type: 'expense',
        category: '',
        amount: '',
        description: '',
        date: new Date().toISOString().split('T')[0]
      })
    } else {
      alert('B≈ÇƒÖd przy dodawaniu transakcji: ' + result.error)
    }
  }

   const handleCloseForm = () => {
    setShowAddForm(false);
    localStorage.removeItem('openExpenseForm');
  };

  const totalExpenses = sortedTransactions.reduce((sum, t) => sum + t.amount, 0)

  return (
    <div className="expenses-tab">
      <div className="tab-header">
        <h3>Koszty</h3>
        <div className="tab-actions">
          {/* SEKCJA SORTOWANIA I FILTROWANIA */}
          <div className="sort-filter-section">
            <label>Sortowanie</label>

            {/* PIERWSZY select - Filtrowanie */}
            <select
              className="control-select"
              value={filterOption}
              onChange={(e) => setFilterOption(e.target.value)}
            >
              <option value="all">Wszystkie kategorie</option>
              {expenseCategories.map(cat => (
                <option key={cat.id} value={cat.id}>
                  {cat.name}
                </option>
              ))}
              {/* Mo≈ºesz zachowaƒá opcje auto/manual je≈õli potrzebujesz */}
              <option value="auto">Auto-generowane</option>
              <option value="manual">Rƒôczne</option>
            </select>

            {/* DRUGI select - Sortowanie */}
            <select
              className="control-select"
              value={sortOption}
              onChange={(e) => setSortOption(e.target.value)}
            >
              {sortOptions.map(option => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </div>

          <button
            className="btn btn-primary"
            onClick={() => setShowAddForm(true)}
          >
            + Dodaj koszt
          </button>
        </div>
      </div>

      <div className="total-summary">
        ≈ÅƒÖczne koszty: <strong>{formatCurrency(totalExpenses)}</strong>
        {filterOption !== 'all' && (
          <span className="filter-info">
            (Filtr: {filterOptions.find(f => f.value === filterOption)?.label})
          </span>
        )}
      </div>

      {/* Reszta kodu pozostaje bez zmian */}
     {showAddForm && (
  <div className="modal-overlay">
    <div className="modal-content">
      <div className="modal-header">
        <h4>Dodaj nowy koszt</h4>
        {/* ZMIE≈É TƒÑ LINIƒò: */}
        <button className="close-btn" onClick={handleCloseForm}>√ó</button>
            </div>
            <form onSubmit={handleAddTransaction}>
              <div className="form-group">
                <label>Kategoria *</label>
                <CustomSelect
                  options={categoryOptions}
                  value={newTransaction.category}
                  onChange={(value) => setNewTransaction(prev => ({ ...prev, category: value }))}
                  placeholder="Wybierz kategoriƒô..."
                  searchable={true}
                />
              </div>

              <div className="form-group">
                <label>Kwota (z≈Ç) *</label>
                <input
                  type="number"
                  step="0.01"
                  value={newTransaction.amount}
                  onChange={(e) => setNewTransaction(prev => ({ ...prev, amount: e.target.value }))}
                  required
                />
              </div>

              <div className="form-group">
                <label>Opis *</label>
                <input
                  type="text"
                  value={newTransaction.description}
                  onChange={(e) => setNewTransaction(prev => ({ ...prev, description: e.target.value }))}
                  required
                />
              </div>

              <div className="form-group">
                <label>Data</label>
                <input
                  type="date"
                  value={newTransaction.date}
                  onChange={(e) => setNewTransaction(prev => ({ ...prev, date: e.target.value }))}
                />
              </div>

              <div className="form-actions">

  <button type="button" className="btn btn-secondary" onClick={handleCloseForm}>
    Anuluj
  </button>
                <button type="submit" className="btn btn-primary">
                  Dodaj koszt
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      <div className="transactions-table">
        <table>
          <thead>
            <tr>
              <th>Data</th>
              <th>Kategoria</th>
              <th>Opis</th>
              <th>Kwota</th>
              <th>Szczeg√≥≈Çy</th>
              <th>Typ</th>
            </tr>
          </thead>
          <tbody>
            {sortedTransactions.map(transaction => {
              // Pobierz czƒô≈õci dla tej transakcji
              const parts = partsData[transaction.id]

              return (
                <tr key={transaction.id}>
                  <td>{transaction.date?.toLocaleDateString?.() || new Date(transaction.date).toLocaleDateString()}</td>
                  <td>
                    <span className="category-with-icon">
                      <span className="icon">
                        {expenseCategories.find(cat => cat.id === transaction.category)?.icon || 'üìâ'}
                      </span>
                      {expenseCategories.find(cat => cat.id === transaction.category)?.name || transaction.category}
                    </span>
                  </td>
                  <td>{transaction.description}</td>
                  <td className="amount negative">-{formatCurrency(transaction.amount)}</td>

                  {/* KOLUMNA - Szczeg√≥≈Çy - TYLKO CZƒò≈öCI LUB "Brak" */}
                  <td>
                    {transaction.productName ? (
                      <span className="product-badge">
                        {transaction.productName}
                        {transaction.quantity && ` (${transaction.quantity} ${transaction.unit})`}
                      </span>
                    ) : transaction.autoGenerated ? (
                      // Dla transakcji z gara≈ºu poka≈º czƒô≈õci
                      transaction.source === 'garage' ? (
                        <div className="parts-container">
                          {parts ? (
                            <span className="parts-badge">{parts}</span>
                          ) : (
                            <span className="no-parts">Brak</span>
                          )}
                        </div>
                      ) : (
                        <span className="auto-details">Transakcja automatyczna</span>
                      )
                    ) : (
                      <span className="manual-details">Brak szczeg√≥≈Ç√≥w</span>
                    )}
                  </td>

                  {/* Kolumna Typ */}
                  <td>
                    {transaction.autoGenerated ? (
                      <span className="auto-badge">Auto</span>
                    ) : (
                      <span className="manual-badge">Rƒôczne</span>
                    )}
                  </td>
                </tr>
              )
            })}
            {sortedTransactions.length === 0 && (
              <tr>
                <td colSpan="6" className="no-data">Brak transakcji kosztowych</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  )
}

export default ExpensesTab