// services/financeService.js
import { 
  collection, 
  doc, 
  addDoc, 
  updateDoc, 
  deleteDoc,
  Timestamp,
  query,
  where,
  orderBy,
  getDocs
} from 'firebase/firestore'
import { db } from '../config/firebase'

// Transakcje finansowe
export const addFinanceTransaction = async (transactionData) => {
  try {
    const docRef = await addDoc(collection(db, 'finance_transactions'), {
      ...transactionData,
      date: Timestamp.fromDate(new Date(transactionData.date)),
      createdAt: Timestamp.now(),
      amount: parseFloat(transactionData.amount)
    })
    return { success: true, id: docRef.id }
  } catch (error) {
    console.error('Error adding transaction:', error)
    return { success: false, error: error.message }
  }
}

export const updateFinanceTransaction = async (transactionId, updateData) => {
  try {
    const transactionRef = doc(db, 'finance_transactions', transactionId)
    await updateDoc(transactionRef, {
      ...updateData,
      lastUpdate: Timestamp.now(),
      amount: parseFloat(updateData.amount)
    })
    return { success: true }
  } catch (error) {
    console.error('Error updating transaction:', error)
    return { success: false, error: error.message }
  }
}

export const deleteFinanceTransaction = async (transactionId) => {
  try {
    await deleteDoc(doc(db, 'finance_transactions', transactionId))
    return { success: true }
  } catch (error) {
    console.error('Error deleting transaction:', error)
    return { success: false, error: error.message }
  }
}

// Automatyczne transakcje z innych modułów
export const addAutoTransaction = async (type, data) => {
  try {
    const transactionData = {
      type: type, // 'income' lub 'expense'
      category: data.category,
      amount: parseFloat(data.amount),
      description: data.description,
      source: data.source, // 'fields', 'animals', 'warehouse', 'garage'
      sourceId: data.sourceId,
      relatedItem: data.relatedItem, // np. nazwa produktu, pola, zwierzęcia
      date: Timestamp.now(),
      autoGenerated: true,
      createdAt: Timestamp.now()
    }

    const docRef = await addDoc(collection(db, 'finance_transactions'), transactionData)
    return { success: true, id: docRef.id }
  } catch (error) {
    console.error('Error adding auto transaction:', error)
    return { success: false, error: error.message }
  }
}

// Budżety
export const addBudget = async (budgetData) => {
  try {
    const docRef = await addDoc(collection(db, 'finance_budgets'), {
      ...budgetData,
      createdAt: Timestamp.now(),
      amount: parseFloat(budgetData.amount),
      spent: 0
    })
    return { success: true, id: docRef.id }
  } catch (error) {
    console.error('Error adding budget:', error)
    return { success: false, error: error.message }
  }
}

export const updateBudget = async (budgetId, updateData) => {
  try {
    const budgetRef = doc(db, 'finance_budgets', budgetId)
    await updateDoc(budgetRef, {
      ...updateData,
      lastUpdate: Timestamp.now()
    })
    return { success: true }
  } catch (error) {
    console.error('Error updating budget:', error)
    return { success: false, error: error.message }
  }
}

// Pobieranie danych do raportów
export const getTransactionsByPeriod = async (startDate, endDate) => {
  try {
    const q = query(
      collection(db, 'finance_transactions'),
      where('date', '>=', Timestamp.fromDate(startDate)),
      where('date', '<=', Timestamp.fromDate(endDate)),
      orderBy('date', 'desc')
    )
    
    const querySnapshot = await getDocs(q)
    const transactions = []
    querySnapshot.forEach((doc) => {
      const data = doc.data()
      transactions.push({ 
        id: doc.id, 
        ...data,
        date: data.date?.toDate?.() || data.date
      })
    })
    
    return { success: true, transactions }
  } catch (error) {
    console.error('Error getting transactions by period:', error)
    return { success: false, error: error.message }
  }
}

// Statystyki finansowe
export const getFinanceStats = async (period = 'month') => {
  try {
    const now = new Date()
    let startDate
    
    switch (period) {
      case 'week':
        startDate = new Date(now.setDate(now.getDate() - 7))
        break
      case 'month':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1)
        break
      case 'year':
        startDate = new Date(now.getFullYear(), 0, 1)
        break
      default:
        startDate = new Date(now.getFullYear(), now.getMonth(), 1)
    }

    const q = query(
      collection(db, 'finance_transactions'),
      where('date', '>=', Timestamp.fromDate(startDate)),
      where('date', '<=', Timestamp.now()),
      orderBy('date', 'desc')
    )
    
    const querySnapshot = await getDocs(q)
    let income = 0
    let expenses = 0
    const categories = {}

    querySnapshot.forEach((doc) => {
      const data = doc.data()
      const amount = data.amount || 0
      
      if (data.type === 'income') {
        income += amount
      } else {
        expenses += amount
      }

      // Grupowanie po kategoriach
      const category = data.category
      if (!categories[category]) {
        categories[category] = { income: 0, expenses: 0 }
      }
      
      if (data.type === 'income') {
        categories[category].income += amount
      } else {
        categories[category].expenses += amount
      }
    })

    return {
      success: true,
      stats: {
        income,
        expenses,
        balance: income - expenses,
        categories
      }
    }
  } catch (error) {
    console.error('Error getting finance stats:', error)
    return { success: false, error: error.message }
  }
}